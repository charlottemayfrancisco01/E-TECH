<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kids Jigsaw Puzzle</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: "Comic Sans MS", "Poppins", Arial, sans-serif;
    background: linear-gradient(135deg, #a18cd1, #fbc2eb);
  }
  canvas { display: block; touch-action: none; }
  
  /* Navigation Links - Higher Z-Index to show above overlays */
  .topLink {
    position: fixed; left:15px; z-index: 1000;
    padding: 10px 16px; font-size:14px; border-radius:14px;
    background:#6a5acd; color:white; text-decoration:none; font-weight:bold;
    box-shadow:0 6px 15px rgba(0,0,0,0.2); transition:0.3s;
  }
  .topLink:nth-child(1){ top:15px; }
  .topLink:nth-child(2){ top:60px; }
  .topLink:hover { transform: scale(1.08); background:#5846c9; }

  /* Header Instruction */
  #mainHeader {
    position: fixed;
    top: 20px;          
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    font-size: 22px;
    font-weight: bold;
    text-align: center;
    z-index: 5;
    width: 60%; /* Reduced width to avoid overlapping topLinks */
    color: #4b145f;
    text-shadow: 1px 1px 0px white;
  }

  /* Start Screen Overlay */
  #startScreen {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #a18cd1, #fbc2eb);
    z-index: 500; /* Below topLinks */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }

  .start-content {
    background: white;
    padding: 40px;
    border-radius: 40px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    max-width: 600px;
    border: 8px solid #fbc2eb;
  }

  .start-content h1 { color: #4b145f; font-size: 32px; margin-top: 0; }

  .instructions-box {
    text-align: left;
    background: #fdf2f9;
    padding: 20px;
    border-radius: 20px;
    margin: 20px 0;
    color: #555;
    font-size: 18px;
    line-height: 1.6;
  }

  .start-btn {
    padding: 15px 40px;
    font-size: 22px;
    background: linear-gradient(135deg, #ff9a9e, #fad0c4);
    color: #4b145f;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 10px 20px rgba(255, 154, 158, 0.4);
    transition: 0.3s;
  }

  .start-btn:hover { transform: scale(1.1); }

  #ui {
    position: fixed; bottom: 20px; right: 20px; z-index: 10;
    display: flex; gap: 10px;
  }
  button {
    padding: 12px 18px;
    background: linear-gradient(135deg, #ff9a9e, #fad0c4);
    color: #4b145f;
    border: none; border-radius: 20px;
    font-weight: bold; cursor: pointer;
    box-shadow: 0 6px 15px rgba(0,0,0,0.25);
    transition: transform 0.2s, box-shadow 0.2s;
    font-size: 16px;
  }
  
  #skipBtn { background: linear-gradient(135deg, #89f7fe, #66a6ff); color: #004e92; }

  #levelInfo {
    position: fixed;
    top: 100px;          
    right: 20px;
    background: rgba(255,255,255,0.95);
    color: #4b145f;
    padding: 26px;
    border-radius: 26px;
    max-width: 380px;
    box-shadow: 0 16px 40px rgba(0,0,0,0.3);
    z-index: 10;
  }
  #levelInfo h2 { margin: 0 0 12px; font-size: 24px; font-weight: bold; }
  #levelInfo p { margin: 0; font-size: 18px; line-height: 1.6; }

  #completionPopup {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 500; /* Below topLinks */
    backdrop-filter: blur(5px);
    justify-content: center;
    align-items: center;
  }

  #completionPopup div.popup-content {
    background: white;
    padding: 40px 60px;
    border-radius: 30px;
    text-align: center;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    border: 4px solid #fbc2eb;
    display: flex;
    flex-direction: column;
    align-items: center;    
    gap: 20px;
    min-width: 300px;
  }

  .stars { font-size: 40px; letter-spacing: 5px; margin-bottom: 10px; }
  .score-display { font-size: 24px; color: #333; margin: 10px 0; }
  .confetti { position: fixed; width: 10px; height: 10px; top: -10px; animation: fall 3s linear forwards; z-index: 999; }
  @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity:0; } }
</style>
</head>
<body>

<!-- Navigation links are outside overlays with highest z-index -->
<a href="activities.html" class="topLink">Activities</a>
<a href="lottie.html" class="topLink">Story</a>

<div id="startScreen">
  <div class="start-content">
    <h1>PUZZLE-TATION</h1>
    <div class="instructions-box">
      <strong>Panuto:</strong>
      <ul>
        <li>Basahin mabuti ang bawat tanong at buoin ang tamang sagot gamit ang puzzle.</li>
      </ul>
    </div>
    <button class="start-btn" onclick="startGame()">Simulan ang Laro</button>
  </div>
</div>

<div id="ui">
  <button id="skipBtn" onclick="skipLevel()">Skip Level</button>
  <button id="nextBtn" onclick="nextLevel()"> Next Level</button>
</div>

<div id="levelInfo">
  <h2 id="levelTitle"></h2>
  <p id="levelDesc"></p>
</div>

<canvas id="canvas"></canvas>

<div id="completionPopup">
  <div class="popup-content">
    <h2 id="popupTitle">Set Completed!</h2>
    <div id="scoreDetails">
        <div class="stars" id="starDisplay">⭐⭐⭐⭐⭐</div>
        <div class="score-display" id="scoreText">Score: 5 / 5</div>
    </div>
    <button id="playAgainBtn">Play Next Set</button>
  </div>
</div>

<script>
let audioCtx;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let levelCompleted = false;
let score = 0; 
let gameStarted = false;
let pieces = [];
let groups = [];
let levelIndex = 0;
let board = null;
let currentSet = 1; 
let currentImageIndex = 0;

const SNAP = 18;
const TAB_RATIO = 0.28;
const BLEED_RATIO = 0.3;

const LEVELS = [{ rows: 2, cols: 2 }];
const IMAGES_SET_1 = [
  { src: "P1.png", desc: "1. Ano ang tawag sa bahagi ng presentation software kung saan makikita ang kabuuang itsura ng software..." },
  { src: "P2.png", desc: "2. Ano ang ginagamit upang mabilis na mabigyan ng kulay, font style, at layout ang lahat ng slides?" },
  { src: "P3.png", desc: "3. Ito ay isang masining na paraan ng pagpapakita ng teksto..." },
  { src: "P4.png", desc: "4. Ito ay ang proseso na ginagamit para mag lagay ng teksto..." },
  { src: "P5.png", desc: "5. Ano ang proseso ng pagdaragdag ng larawan, video, o chart sa isang slide?" }
];
const IMAGES_SET_2 = [
  { src: "P6.jpg", desc: "1. Ang ______ay masining na paraan ng pagpapakita ng teksto..." },
  { src: "P7.jpg", desc: "2. Mahalaga ito upang hindi mawala ang ginagawa lalo na kung biglang mawalan ng kuryente." },
  { src: "P8.jpg", desc: "3. Ito ay bahagi ng software kung saan makikita ang mga tools tulad ng Bold, Italic..." },
  { src: "P9.jpg", desc: "4. Ito ay isang software na ginagamit upang gumawa ng slide presentation..." },
  { src: "P10.jpg", desc: "5. Ano ang tawag sa bawat pahina ng PowerPoint presentation?" }
];

let currentImageData = IMAGES_SET_1[0];
const image = new Image();
const imageCanvas = document.createElement("canvas");
const imageCtx = imageCanvas.getContext("2d");

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const now = audioCtx.currentTime;
    if (type === 'pop') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(); osc.stop(now + 0.1);
    } else if (type === 'success') {
        [523, 659, 783].forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(f, now + i*0.05);
            gain.gain.setValueAtTime(0.05, now + i*0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.05 + 0.15);
            osc.start(now + i*0.05); osc.stop(now + i*0.05 + 0.15);
        });
    } else if (type === 'win') {
        [523, 659, 783, 1046].forEach((f, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.value = f;
            gain.gain.setValueAtTime(0.1, now + i*0.1);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.2);
            osc.start(now + i*0.1); osc.stop(now + i*0.1 + 0.2);
        });
    }
}

function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
resize();
addEventListener("resize", resize);

function getBoard() {
  const size = Math.min(canvas.width, canvas.height) * 0.55;
  return { x: (canvas.width - size)/2, y: (canvas.height - size)/2, size };
}

function leftSideSpawn(board, pieceW, pieceH, index) {
  const margin = 10;
  const piecesPerColumn = Math.floor(canvas.height / (pieceH + margin));
  const row = index % piecesPerColumn;
  const col = Math.floor(index / piecesPerColumn);
  return { x: margin + col * (pieceW + margin), y: margin + row * (pieceH + margin) };
}

class Piece {
  constructor(r,c,w,h,edges,board,index){
    this.row=r; this.col=c; this.w=w; this.h=h; this.edges=edges;
    this.bleed=Math.min(w,h)*BLEED_RATIO;
    this.drawW=w+2*this.bleed; this.drawH=h+2*this.bleed;
    this.correctX=board.x+c*w-this.bleed;
    this.correctY=board.y+r*h-this.bleed;
    const spawn = leftSideSpawn(board,this.drawW,this.drawH,index);
    this.x=spawn.x; this.y=spawn.y;
    this.group=null;
  }
  draw(){
    ctx.save(); ctx.translate(this.x,this.y); ctx.beginPath();
    ctx.translate(this.bleed,this.bleed); drawJigsawPath(ctx,this.w,this.h,this.edges); ctx.closePath(); ctx.clip();
    ctx.drawImage(imageCanvas,this.col*this.w-this.bleed,this.row*this.h-this.bleed,this.w+2*this.bleed,this.h+2*this.bleed,-this.bleed,-this.bleed,this.w+2*this.bleed,this.h+2*this.bleed);
    ctx.restore();
    ctx.save(); ctx.translate(this.x,this.y); ctx.beginPath(); ctx.translate(this.bleed,this.bleed);
    drawJigsawPath(ctx,this.w,this.h,this.edges); ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.lineWidth=1; ctx.stroke(); ctx.restore();
  }
}

class Group {
  constructor(p){ this.pieces=[p]; p.group=this; }
  move(dx,dy){ this.pieces.forEach(p=>{p.x+=dx;p.y+=dy;}); }
  trySnap(other){
    for(let a of this.pieces){ for(let b of other.pieces){
      const dr=a.row-b.row, dc=a.col-b.col;
      if(Math.abs(dr)+Math.abs(dc)!==1) continue;
      const dx=a.x-b.x-(a.correctX-b.correctX);
      const dy=a.y-b.y-(a.correctY-b.correctY);
      if(Math.abs(dx)<SNAP && Math.abs(dy)<SNAP){ 
          other.move(dx,dy); 
          this.merge(other); 
          playSound('pop');
          return true; 
      }
    }}
    return false;
  }
  merge(other){ other.pieces.forEach(p=>p.group=this); this.pieces.push(...other.pieces); groups=groups.filter(g=>g!==other);}
}

function drawJigsawPath(ctx,w,h,e){
  const t=Math.min(w,h)*TAB_RATIO;
  ctx.moveTo(0,0);
  if(e.top===0) ctx.lineTo(w,0); else ctx.bezierCurveTo(w/4,-t*e.top,3*w/4,-t*e.top,w,0);
  if(e.right===0) ctx.lineTo(w,h); else ctx.bezierCurveTo(w+t*e.right,h/4,w+t*e.right,3*h/4,w,h);
  if(e.bottom===0) ctx.lineTo(0,h); else ctx.bezierCurveTo(3*w/4,h+t*e.bottom,w/4,h+t*e.bottom,0,h);
  if(e.left===0) ctx.lineTo(0,0); else ctx.bezierCurveTo(-t*e.left,3*h/4,-t*e.left,h/4,0,0);
}

function startPuzzle(){
  if(!gameStarted) return;
  levelCompleted=false;
  document.getElementById("nextBtn").disabled=true;
  document.getElementById("skipBtn").disabled=false;
  pieces=[]; board=getBoard();
  imageCanvas.width=board.size; imageCanvas.height=board.size;
  const scale=Math.min(board.size/image.width,board.size/image.height);
  imageCtx.drawImage(image, (board.size-image.width*scale)/2, (board.size-image.height*scale)/2, image.width*scale, image.height*scale);

  const lvl=LEVELS[0];
  const pw=board.size/lvl.cols, ph=board.size/lvl.rows;
  const edges=[];
  for(let r=0;r<lvl.rows;r++){ edges[r]=[]; for(let c=0;c<lvl.cols;c++){
    edges[r][c]={ top:r===0?0:-edges[r-1][c].bottom, left:c===0?0:-edges[r][c-1].right, right:c===lvl.cols-1?0:(Math.random()>0.5?1:-1), bottom:r===lvl.rows-1?0:(Math.random()>0.5?1:-1) };
  }}
  let idx=0;
  for(let r=0;r<lvl.rows;r++) for(let c=0;c<lvl.cols;c++) pieces.push(new Piece(r,c,pw,ph,edges[r][c],board,idx++));
  groups = pieces.map(p => new Group(p));
}

function startGame() {
    initAudio();
    document.getElementById("startScreen").style.display = "none";
    gameStarted = true;
    image.src = currentImageData.src;
}

function spawnConfetti(){ for(let i=0;i<20;i++){ const c=document.createElement("div"); c.className="confetti"; c.style.left=Math.random()*100+"vw"; c.style.background=`hsl(${Math.random()*360},100%,70%)`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000); }}

function showCompletionPopup(totalInSet) {
    const popup = document.getElementById("completionPopup");
    const scoreText = document.getElementById("scoreText");
    const starDisplay = document.getElementById("starDisplay");
    let stars = score === totalInSet ? "⭐⭐⭐⭐⭐" : score >= totalInSet*0.6 ? "⭐⭐⭐⚫⚫" : "⭐⚫⚫⚫⚫";
    scoreText.textContent = `Score: ${score} / ${totalInSet}`;
    starDisplay.textContent = stars;
    popup.style.display = "flex";
    playSound('win');
    spawnConfetti();
}

function loadNextLevel() {
    const arr = currentSet === 1 ? IMAGES_SET_1 : IMAGES_SET_2;
    currentImageIndex++;
    if(currentImageIndex >= arr.length){
        showCompletionPopup(arr.length);
        return;
    }
    currentImageData = arr[currentImageIndex];
    image.src = currentImageData.src;
    document.getElementById("levelDesc").textContent = currentImageData.desc;
}

function skipLevel() { loadNextLevel(); }
function nextLevel(){ if(levelCompleted) loadNextLevel(); }

image.onload = startPuzzle;
document.getElementById("levelDesc").textContent = currentImageData.desc;

let active=null,ox=0,oy=0;
function getPos(e){ const r=canvas.getBoundingClientRect(); const t=e.touches?e.touches[0]:e; return {x:t.clientX-r.left,y:t.clientY-r.top}; }

canvas.addEventListener("pointerdown", e=>{
    if (!gameStarted) return;
    initAudio();
    const pos=getPos(e); 
    for(let i=pieces.length-1;i>=0;i--){ 
        const p=pieces[i]; 
        if(pos.x>p.x && pos.x<p.x+p.drawW && pos.y>p.y && pos.y<p.y+p.drawH){ active=p.group; ox=pos.x; oy=pos.y; break; } 
    }
}); 
addEventListener("pointermove",e=>{ if(active){ const p=getPos(e); active.move(p.x-ox,p.y-oy); ox=p.x; oy=p.y; }}); 
addEventListener("pointerup",()=>{ if(active){ for(let g of groups) if(g!==active && active.trySnap(g)) break; active=null; checkWin(); }});

function checkWin(){ 
  if(!levelCompleted && groups.length === 1){
    levelCompleted = true; score++;
    playSound('success'); spawnConfetti();
    document.getElementById("skipBtn").disabled = true;
    const arr = currentSet === 1 ? IMAGES_SET_1 : IMAGES_SET_2;
    if (currentImageIndex === arr.length - 1) setTimeout(() => showCompletionPopup(arr.length), 500);
    else document.getElementById("nextBtn").disabled = false;
  }
}

document.getElementById("playAgainBtn").addEventListener("click", () => {
  document.getElementById("completionPopup").style.display="none";
  score = 0; currentSet = currentSet === 1 ? 2 : 1;
  currentImageIndex = 0; currentImageData = (currentSet === 1 ? IMAGES_SET_1 : IMAGES_SET_2)[0];
  image.src = currentImageData.src;
  document.getElementById("levelDesc").textContent = currentImageData.desc;
});

function loop(){ 
  ctx.clearRect(0,0,canvas.width,canvas.height); 
  if(gameStarted){
    if(board){ ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.strokeRect(board.x,board.y,board.size,board.size); }
    pieces.forEach(p=>p.draw()); 
  }
  requestAnimationFrame(loop); 
}
loop();
</script>
</body>
</html>
