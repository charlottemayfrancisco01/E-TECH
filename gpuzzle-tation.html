<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kids Jigsaw Puzzle</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: "Comic Sans MS", "Poppins", Arial, sans-serif;
    background: linear-gradient(135deg, #a18cd1, #fbc2eb);
  }
  canvas { display: block; touch-action: none; }
  h2 {
    position: fixed;
    top: 20px;          
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    font-size: 26px;
    font-weight: bold;
    text-align: center;
    z-index: 5;         
  }
  #ui {
    position: fixed; bottom: 20px; right: 20px; z-index: 10;
  }
  button {
    padding: 12px 18px;
    background: linear-gradient(135deg, #ff9a9e, #fad0c4);
    color: #4b145f;
    border: none; border-radius: 20px;
    font-weight: bold; cursor: pointer;
    box-shadow: 0 6px 15px rgba(0,0,0,0.25);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  button:hover { transform: scale(1.08); box-shadow: 0 10px 25px rgba(0,0,0,0.35); }
  #levelInfo {
    position: fixed;
    top: 80px;          
    right: 20px;
    background: rgba(255,255,255,0.95);
    color: #4b145f;
    padding: 26px;
    border-radius: 26px;
    max-width: 380px;
    box-shadow: 0 16px 40px rgba(0,0,0,0.3);
    z-index: 10;
  }
  #levelInfo h2 { margin: 0 0 12px; font-size: 26px; font-weight: bold; }
  #levelInfo p { margin: 0; font-size: 18px; line-height: 1.6; }
  button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
  .confetti { position: fixed; width: 10px; height: 10px; top: -10px; animation: fall 3s linear forwards; z-index: 999; }
  @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity:0; } }
  .topLink {
    position: fixed; left:15px; z-index:10;
    padding: 10px 16px; font-size:14px; border-radius:14px;
    background:#6a5acd; color:white; text-decoration:none; font-weight:bold;
    box-shadow:0 6px 15px rgba(0,0,0,0.2); transition:0.3s;
  }
  .topLink:nth-child(1){ top:15px; }
  .topLink:nth-child(2){ top:60px; }
  .topLink:hover { transform: scale(1.08); background:#5846c9; }
  #completionPopup {
    display: none;
    position: fixed; top:0; left:0; width:100%; height:100%;
    background: rgba(0,0,0,0.4); z-index: 20;
  }
  #completionPopup div {
    position: fixed; top:50%; left:50%; transform: translate(-50%,-50%);
    background:white; padding:40px; border-radius:20px; text-align:center;
    box-shadow:0 10px 40px rgba(0,0,0,0.4);
  }
  #completionPopup h2 { font-size:32px; color:#4b145f; margin-bottom:20px; }
</style>
</head>
<body>

<a href="activities.html" class="topLink">Activities</a>
<a href="lottie.html" class="topLink">Story</a>

<h2>Panuto: Basahin mabuti ang bawat tanong at buoin ang tamang sagot gamit ang puzzle.</h2>

<div id="ui">
  <button id="nextBtn" onclick="nextLevel()"> Next Level</button>
</div>

<div id="levelInfo">
  <h2 id="levelTitle"></h2>
  <p id="levelDesc"></p>
</div>

<canvas id="canvas"></canvas>

<div id="completionPopup">
  <div>
    <h2>Well Done!</h2>
    <button id="playAgainBtn">Play Again</button>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let levelCompleted = false;

function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
resize();
addEventListener("resize", resize);

const LEVELS = [{ rows: 2, cols: 2 }];

const IMAGES_SET_1 = [
  { src: "P1.png", title: "", desc: "1. Ano ang tawag sa bahagi ng presentation software kung saan makikita ang kabuuang itsura ng software kung saan nandiyan ang mga menu, toolbar, slide panel at workspace." },
  { src: "P2.png", title: "", desc: "2. Ano ang ginagamit upang mabilis na mabigyan ng kulay, font style, at layout ang lahat ng slides sa isang presentasyon?" },
  { src: "P3.png", title: "", desc: "3. Ito ay isang masining na paraan ng pagpapakita ng teksto. Ginagamit ito para mas maging kaakit-akit ang mga salita sa presentation." },
  { src: "P4.png", title: "", desc: "4. Ito ay ang proseso na ginagamit para mag lagay ng teksto. Pwede rin itong i-format at baguhin ang font,laki, kulay at alignment." },
  { src: "P5.png", title: "", desc: "5. Ano ang proseso ng pagdaragdag ng larawan, video, o chart sa isang slide upang mas maging malinaw ang impormasyon?" }
];

const IMAGES_SET_2 = [
  { src: "P6.png", title: "", desc: "1. Ano ang tawag sa bahagi ng presentation software kung saan makikita ang kabuuang itsura ng software kung saan nandiyan ang mga menu, toolbar, slide panel at workspace." },
  { src: "P7.png", title: "", desc: "2. Ano ang ginagamit upang mabilis na mabigyan ng kulay, font style, at layout ang lahat ng slides sa isang presentasyon?" },
  { src: "P8.png", title: "", desc: "3. Ito ay isang masining na paraan ng pagpapakita ng teksto. Ginagamit ito para mas maging kaakit-akit ang mga salita sa presentation." },
  { src: "P9.png", title: "", desc: "4. Ito ay ang proseso na ginagamit para mag lagay ng teksto. Pwede rin itong i-format at baguhin ang font,laki, kulay at alignment." },
  { src: "P10.png", title: "", desc: "5. Ano ang proseso ng pagdaragdag ng larawan, video, o chart sa isang slide upang mas maging malinaw ang impormasyon?" }
];

let pieces = [];
let groups = [];
let levelIndex = 0;
let board = null;

let currentSet = 1;
let currentImageIndex = 0;
let currentImageData = IMAGES_SET_1[0];

const SNAP = 18;
const TAB_RATIO = 0.28;
const BLEED_RATIO = 0.3;

const image = new Image();
const imageCanvas = document.createElement("canvas");
const imageCtx = imageCanvas.getContext("2d");

function getBoard() {
  const size = Math.min(canvas.width, canvas.height) * 0.55;
  return { x: (canvas.width - size)/2, y: (canvas.height - size)/2, size };
}

function leftSideSpawn(board, pieceW, pieceH, index) {
  const margin = 8;
  const piecesPerColumn = Math.floor(canvas.height / (pieceH + margin));
  const row = index % piecesPerColumn;
  const col = Math.floor(index / piecesPerColumn);
  return { x: margin + col * (pieceW + margin), y: margin + row * (pieceH + margin) };
}

class Piece {
  constructor(r,c,w,h,edges,board,index){
    this.row=r; this.col=c; this.w=w; this.h=h; this.edges=edges;
    this.bleed=Math.min(w,h)*BLEED_RATIO;
    this.drawW=w+2*this.bleed; this.drawH=h+2*this.bleed;
    this.correctX=board.x+c*w-this.bleed;
    this.correctY=board.y+r*h-this.bleed;
    const spawn = leftSideSpawn(board,this.drawW,this.drawH,index);
    this.x=spawn.x; this.y=spawn.y;
    this.group=null;
  }
  draw(){
    ctx.save(); ctx.translate(this.x,this.y); ctx.beginPath();
    ctx.translate(this.bleed,this.bleed); drawJigsawPath(ctx,this.w,this.h,this.edges); ctx.closePath(); ctx.clip();
    ctx.drawImage(imageCanvas,this.col*this.w-this.bleed,this.row*this.h-this.bleed,this.w+2*this.bleed,this.h+2*this.bleed,-this.bleed,-this.bleed,this.w+2*this.bleed,this.h+2*this.bleed);
    ctx.restore();
    ctx.save(); ctx.translate(this.x,this.y); ctx.beginPath(); ctx.translate(this.bleed,this.bleed);
    drawJigsawPath(ctx,this.w,this.h,this.edges); ctx.strokeStyle="rgba(255,255,255,0.35)"; ctx.lineWidth=1; ctx.stroke(); ctx.restore();
  }
}

class Group {
  constructor(p){ this.pieces=[p]; p.group=this; }
  move(dx,dy){ this.pieces.forEach(p=>{p.x+=dx;p.y+=dy;}); }
  trySnap(other){
    for(let a of this.pieces){ for(let b of other.pieces){
      const dr=a.row-b.row, dc=a.col-b.col;
      if(Math.abs(dr)+Math.abs(dc)!==1) continue;
      const dx=a.x-b.x-(a.correctX-b.correctX);
      const dy=a.y-b.y-(a.correctY-b.correctY);
      if(Math.abs(dx)<SNAP && Math.abs(dy)<SNAP){ other.move(dx,dy); this.merge(other); return true; }
    }}
    return false;
  }
  merge(other){ other.pieces.forEach(p=>p.group=this); this.pieces.push(...other.pieces); groups=groups.filter(g=>g!==other);}
}

function drawJigsawPath(ctx,w,h,e){
  const t=Math.min(w,h)*TAB_RATIO;
  ctx.moveTo(0,0);
  if(e.top===0) ctx.lineTo(w,0); else ctx.bezierCurveTo(w/4,-t*e.top,3*w/4,-t*e.top,w,0);
  if(e.right===0) ctx.lineTo(w,h); else ctx.bezierCurveTo(w+t*e.right,h/4,w+t*e.right,3*h/4,w,h);
  if(e.bottom===0) ctx.lineTo(0,h); else ctx.bezierCurveTo(3*w/4,h+t*e.bottom,w/4,h+t*e.bottom,0,h);
  if(e.left===0) ctx.lineTo(0,0); else ctx.bezierCurveTo(-t*e.left,3*h/4,-t*e.left,h/4,0,0);
}

function spawnPieces(){ groups=[]; pieces.forEach(p=>groups.push(new Group(p))); }

function startPuzzle(){
  levelCompleted=false;
  document.getElementById("nextBtn").disabled=true;
  pieces=[]; board=getBoard();
  imageCanvas.width=board.size; imageCanvas.height=board.size;
  imageCtx.fillStyle="black"; imageCtx.fillRect(0,0,board.size,board.size);
  const scale=Math.min(board.size/image.width,board.size/image.height);
  const drawW=image.width*scale, drawH=image.height*scale;
  const dx=(board.size-drawW)/2, dy=(board.size-drawH)/2;
  imageCtx.drawImage(image,dx,dy,drawW,drawH);

  const lvl=LEVELS[levelIndex];
  const pw=board.size/lvl.cols, ph=board.size/lvl.rows;
  const edges=[];
  for(let r=0;r<lvl.rows;r++){ edges[r]=[]; for(let c=0;c<lvl.cols;c++){
    edges[r][c]={ top:r===0?0:-edges[r-1][c].bottom, left:c===0?0:-edges[r][c-1].right, right:c===lvl.cols-1?0:(Math.random()>0.5?1:-1), bottom:r===lvl.rows-1?0:(Math.random()>0.5?1:-1) };
  }}
  let index=0;
  for(let r=0;r<lvl.rows;r++){ for(let c=0;c<lvl.cols;c++){ const p=new Piece(r,c,pw,ph,edges[r][c],board,index++); pieces.push(p); }}
  spawnPieces();
}

function spawnConfetti(){ for(let i=0;i<30;i++){ const c=document.createElement("div"); c.className="confetti"; c.style.left=Math.random()*100+"vw"; c.style.background=`hsl(${Math.random()*360},100%,70%)`; c.style.animationDelay=Math.random()*0.4+"s"; document.body.appendChild(c); setTimeout(()=>c.remove(),3000); }}

function nextLevel(){
  if(!levelCompleted) return;
  levelIndex = (levelIndex+1)%LEVELS.length;

  if(currentSet === 1){
    currentImageIndex++;
    if(currentImageIndex >= IMAGES_SET_1.length){
      currentSet = 2;
      currentImageIndex = 0;
    }
    currentImageData = currentSet===1 ? IMAGES_SET_1[currentImageIndex] : IMAGES_SET_2[currentImageIndex];
  } else {
    currentImageIndex++;
    if(currentImageIndex >= IMAGES_SET_2.length){
      document.getElementById("completionPopup").style.display="block";
      return;
    }
    currentImageData = IMAGES_SET_2[currentImageIndex];
  }

  image.src = currentImageData.src;
  document.getElementById("levelTitle").textContent = currentImageData.title;
  document.getElementById("levelDesc").textContent = currentImageData.desc;
}

image.onload=startPuzzle;
image.src=currentImageData.src;
document.getElementById("levelTitle").textContent = currentImageData.title;
document.getElementById("levelDesc").textContent = currentImageData.desc;

let active=null,ox=0,oy=0;
function getPointerPos(e){ const rect=canvas.getBoundingClientRect(); const touch=e.touches?e.touches[0]:e; return {x:touch.clientX-rect.left,y:touch.clientY-rect.top}; }
canvas.addEventListener("pointercancel",()=>{active=null;});
canvas.addEventListener("pointerdown",e=>{ const pos=getPointerPos(e); for(let i=pieces.length-1;i>=0;i--){ const p=pieces[i]; if(pos.x>p.x && pos.x<p.x+p.drawW && pos.y>p.y && pos.y<p.y+p.drawH){ active=p.group; ox=pos.x; oy=pos.y; break; } }});
canvas.addEventListener("pointermove",e=>{ if(!active)return; const pos=getPointerPos(e); active.move(pos.x-ox,pos.y-oy); ox=pos.x; oy=pos.y; });
canvas.addEventListener("pointerup",()=>{ if(!active)return; for(let g of groups){ if(g!==active && active.trySnap(g)) break;} active=null; checkLevelComplete(); });

function checkLevelComplete(){ 
  if(!levelCompleted && groups.length===1 && groups[0].pieces.length===pieces.length){
    levelCompleted=true;
    document.getElementById("nextBtn").disabled=false;
    spawnConfetti();
  }
}

document.getElementById("playAgainBtn").addEventListener("click", () => {
  document.getElementById("completionPopup").style.display="none";
  currentSet = 1;
  currentImageIndex = 0;
  levelIndex = 0;
  currentImageData = IMAGES_SET_1[0];
  image.src = currentImageData.src;
  document.getElementById("levelTitle").textContent = currentImageData.title;
  document.getElementById("levelDesc").textContent = currentImageData.desc;
});

function loop(){ 
  ctx.clearRect(0,0,canvas.width,canvas.height); 
  if(board){ ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.lineWidth=2; ctx.strokeRect(board.x,board.y,board.size,board.size);} 
  pieces.forEach(p=>p.draw()); 
  requestAnimationFrame(loop); 
}
loop();
</script>

</body>
</html>
